<script type="text/javascript">

/*

The background page is responsible for the following:
* keeping track of the saved state, as well as what's open.
* retrieving, storing and updating this state in localStorage.
* listening for window/tab events to keep our state up to date.
* saving, opening and deleting windows actions from the popups.

TODO: split background.HTML into multiple JS files (closure?)
FEATURE: omnibox support

*/

var DEFAULT_NAME = "Window";

/* BASIC STATE */
// an array of the names of all saved windows
var savedWindowNames = restoreFromLocalStorage("savedWindowNames", new Array());

// saved windows, keyed by name
// If the savedWindow has an id, it is currently open.
// Each savedWindow can only correspond to one open window at any given time.
var savedWindows = new Object();

// map the ids of open windows to saved window names
// used to respond to events
var windowIdToName = new Object();

/* EDGE CASES */
// saved windows that aren't currently open, keyed by name
// used to match new windows to saved windows that are still closed
var closedWindows = new Object();

// Unfortunately, removing a tab doesn't give us a windowId
// so we need to keep track of that mapping.
var tabIdToSavedWindowId = new Object();

// timeouts used to delay updating the state of a window
// used to process closed windows
var windowIdToTimeout = new Object();

// used to count how many times we show the update message
var updateMsgCount = restoreFromLocalStorage("updateMsgCount", 0);

// whether or not to display a warning
var warning = false;

/* INIT */

// if the extension has been updated, show the update message 5 times 
if (!localStorage.version || parseFloat(localStorage.version) < 1.15) {
  updateMsgCount = 5;
  warning = true;
  // localStorage.version = "1.15";
}
if (updateMsgCount > 0) {
  updateBadgeForAllWindows();
}

// populate savedWindows from local storage
// as we go, try matching them to open windows
chrome.windows.getAll({populate:true}, function(openWindows) {
  for (var i in savedWindowNames) {
    var name = savedWindowNames[i];
    var savedWindow  = restoreFromLocalStorage(name);
    if (savedWindow) {
      savedWindows[name] = savedWindow;
      // by default, we assume the window is closed (id is undefined)
      delete savedWindow.id;
      // now, let's check if it's one of the open windows
      for (var j in openWindows) {
        var w = openWindows[j];
        if (windowsAreEqual(w, savedWindow)) {
          storeWindow(w, name, savedWindow.displayName);
          markWindowAsOpen(w);
          break;
        }
      }
      if (!savedWindows[name].id) {
        closedWindows[name] = savedWindows[name];
      }
    } else {
      console.error("Window " + name + " was not found in localStorage.");
      savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
      localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
    }
  }
});

// helper function to restore from localStorage
function restoreFromLocalStorage(key, defaultValue) {
  if (localStorage[key]) {
    return JSON.parse(localStorage[key]);
  } else {
    localStorage[key] = JSON.stringify(defaultValue);
    return defaultValue;
  }
}

// compares a current window to a saved window
// we are optimistic here: as long as the tabs of the new window
// match those of the saved window, we consider them equal
// even if the new window has more tabs
// TODO: try disregarding query strings (might be better?)
function windowsAreEqual(currentWindow, savedWindow) {
  if (currentWindow.incognito) {
    return false;
  }
  if (!currentWindow.tabs || !savedWindow.tabs) {
    return false;
  }
  if (currentWindow.tabs.length < savedWindow.tabs.length) {
    return false;
  }
  for (var i in savedWindow.tabs) {
    if (currentWindow.tabs[i].url != savedWindow.tabs[i].url) {
      return false;
    }
  }
  return true;
}

// save a window
// returns the saved window object
function saveWindow(w, displayName) {
  var displayName = (displayName == "") ? DEFAULT_NAME : displayName; 
  // handle duplicate names
  var name = displayName;
  var n = 0;
  while(savedWindows[name]) {
    name = displayName + n;
    n++;
  }
  
  // add window to indexes
  savedWindowNames.push(name);
  localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
  
  storeWindow(w, name, displayName);
  
  if (w.id) {
    markWindowAsOpen(w);
  }
  
  return w;
}

// store a window object
// returns the stored window
function storeWindow(w, name, displayName) {
  w.name = name;
  w.displayName = displayName;
  
  savedWindows[name] = w;
  localStorage[name] = JSON.stringify(w);
  
  return w;
}

function markWindowAsOpen(w) {
  delete closedWindows[w.name];
  windowIdToName[w.id] = w.name;
  for (var i in w.tabs) {
    tabIdToSavedWindowId[w.tabs[i].id] = w.id;
  }
  updateBadgeForWindow(w.id);
}

function markWindowAsClosed(w) {
  delete windowIdToName[w.id];
  closedWindows[w.name] = w;
  updateBadgeForWindow(w.id);
  delete w.id;
}

// restore a previously saved window
function openWindow(name) {
  var savedWindow = savedWindows[name];

  chrome.tabs.getSelected(null, function(tab){
    chrome.tabs.getAllInWindow(tab.windowId, function(tabs) {
      var windowId, callback;
      if (tab.url == "chrome://newtab/") {
        // if the newtab was the only tab in the window, re-use the window
        if (tabs.length == 1) {
          // Since we're paranoid, we also check that the window isn't saved
          // just in case you've saved a single newtab (why? don't ask me).
          if (!windowIdToName[tab.windowId]) {
            windowId = tab.windowId;
          }
        } else {
          // if the newtab wasn't the only one, we close it
          chrome.tabs.remove(tab.id);
        }
      }
      
      // this is a little helper function
      // we need it because if we don't have a window yet
      // we'll need to do this work asynchronously
      var openWindowHelper = function openWindowHelper(savedWindow, windowId) {
        savedWindow.id = windowId;
        markWindowAsOpen(savedWindow);
        for (var i in savedWindow.tabs) {
          if (i > 0) {
            // TODO: there could be a race here, if the window gets saved
            chrome.tabs.create({url:savedWindow.tabs[i].url, windowId: windowId});
          }
        }
      }
      
      // If we're re-using the window, we open the tabs directly.
      if (windowId) {
        chrome.tabs.update(tab.id, {url:savedWindow.tabs[0].url});
        openWindowHelper(savedWindow, windowId);
      } else {
        // Otherwise we create a window and open the tabs in it.
        chrome.windows.create({url:savedWindow.tabs[0].url}, function(w){
          openWindowHelper(savedWindow, w.id);
        });
      }
    });
  });
}

// removed a saved window
function deleteSavedWindow(name) {
  var savedWindow = savedWindows[name];
  
  if (savedWindow.id) {
    markWindowAsClosed(savedWindow);
    for (var i in savedWindow.tabs) {
      delete tabIdToSavedWindowId[savedWindow.tabs[i].id];
    }
  }
  
  delete closedWindows[savedWindow.name];
  delete localStorage[name];
  delete savedWindows[name];
  savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
  localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
}

/* BADGE FUNCTIONS */
// Because chrome doesn't support per-window badges, we maintain it per-tab
// and update it on both window and tab selection changes

var regularBadge = { savedText: "v",
                     savedColor: [0,255,0,255],
                     unsavedText: "",
                     unsavedColor: [0,0,0,0]
                   };
var updateBadge = { savedText: "!",
                     savedColor: [255,0,0,255],
                     unsavedText: "!",
                     unsavedColor: [255,0,0,255]
                   };

// returns the type of badge to display given the current state          
function getBadge() {
  if (updateMsgCount > 0) {
    return updateBadge;
  } else {
    return regularBadge;
  }
}

// updates the browserAction badge to show the window as saved
function showSavedBadge(tabId) {
  var badge = getBadge();
  chrome.browserAction.setBadgeText({text:badge.savedText, tabId:tabId});
  chrome.browserAction.setBadgeBackgroundColor(
    {color:badge.savedColor, tabId:tabId});
}

// updates the browserAction badge to show the window as unsaved
// because chrome doesn't support per-window badges, we do it per-tab
// and update it on both window and tab selection changes
function showUnsavedBadge(tabId) {
  var badge = getBadge();
  chrome.browserAction.setBadgeText({text:badge.unsavedText, tabId:tabId});
  chrome.browserAction.setBadgeBackgroundColor(
    {color:badge.unsavedColor, tabId:tabId});
}

// update the badge for the given tab
function updateBadgeForTab(tab) {
  if (windowIdToName[tab.windowId]) {
    showSavedBadge(tab.id);
  } else {
    showUnsavedBadge(tab.id);
  }
}

// update the badge for the given window
function updateBadgeForWindow(windowId) {
  if (windowId != -1) {
    chrome.tabs.getSelected(windowId, updateBadgeForTab);
  }
}

// update the badge for the given window
function updateBadgeForAllWindows() {
  chrome.windows.getAll(null, function(windows) {
    for (i in windows) {
      updateBadgeForWindow(windows[i].id);
    }
  });
}

/* TAB EVENTS */
// For most tab events, we simply resave the entire window.
// While more wasteful, this makes the code much more robust.

function onTabAttached(tabId, info) {
  onTabChanged(tabId, info.newWindowId);
  // TODO: handle the case where this was the last tab of a saved window
}
chrome.tabs.onAttached.addListener(onTabAttached);

function onTabCreated(tab) {
  onTabChanged(tab.id, tab.windowId);
}
chrome.tabs.onCreated.addListener(onTabCreated);

function onTabDetached(tabId, info) {
  if (tabIdToSavedWindowId[tabId]) {
    delete tabIdToSavedWindowId[tabId];
  }
  onTabChanged(tabId, info.oldWindowId);
}
chrome.tabs.onDetached.addListener(onTabDetached);

function onTabMoved(tabId, info) {
  onTabChanged(tabId, info.windowId);
}
chrome.tabs.onMoved.addListener(onTabMoved);

function onTabRemoved(tabId) {
  var windowId = tabIdToSavedWindowId[tabId];
  delete tabIdToSavedWindowId[tabId];
  // because closing a window also triggers tab removal events
  // we delay updating the window to give the window a chance to close
  onTabChangedWithTimeout(tabId, windowId);
  windowIdToTimeout[windowId].count = getNumberOfPendingClosedTabs(windowId) + 1;
  // TODO: can we handle the case when we close the last tab
}
chrome.tabs.onRemoved.addListener(onTabRemoved);

function onTabSelectionChanged(tabId, info) {
  var windowId = info.windowId;
  updateBadgeForTab({id: tabId, windowId: windowId});
  // because closing a window also triggers tab selection events
  // we delay updating the window if there is a tab close event pending
  if (windowIdToTimeout[windowId]) {
    onTabChangedWithTimeout(tabId, windowId);
  } else {
    onTabChanged(tabId, windowId);
  }
}
chrome.tabs.onSelectionChanged.addListener(onTabSelectionChanged);

function onTabUpdated(tabId, info, tab) {
  onTabChanged(tabId, tab.windowId);
}
chrome.tabs.onUpdated.addListener(onTabUpdated);

// updates a window in response to a tab event
function onTabChanged(tabId, windowId) {
  clearTimeoutForWindowId(windowId);
  getPopulatedWindow(windowId, function(w) {
    // if the window is saved, we update it
    if (windowIdToName[windowId]) {
      tabIdToSavedWindowId[tabId] = windowId;
      var name = windowIdToName[windowId];
      var displayName = savedWindows[name].displayName;
      storeWindow(w, name, displayName);
    } else {
      // otherwise we double check that it's not saved
      for (i in closedWindows) {
        var savedWindow = closedWindows[i];
        if (windowsAreEqual(w, savedWindow)) {
          console.log("Window " + windowId + " was identified as " + savedWindow.displayName);
          var name = savedWindow.name;
          var displayName = savedWindow.displayName;
          storeWindow(w, name, displayName);
          markWindowAsOpen(w);
        }
      }
    }
    if (tabId) {
      updateBadgeForTab({id:tabId, windowId:windowId});
    }
  });
}

// given a window id, fetches the corresponding window object
// and tabs, and calls callback with the window as argument
function getPopulatedWindow(windowId, callback) {
  if (!windowId) {return;}
  chrome.windows.get(windowId, function(w) {
    if (!w) {return;}
    chrome.tabs.getAllInWindow(windowId, function(tabs) {
      if (!tabs) {return;}
      w.tabs = tabs;
      callback(w);
    });
  });
}

// sets a timeout to update the state of a window after 5 seconds
// if such a timer already exists, resets it
function onTabChangedWithTimeout(tabId, windowId) {
  var count = getNumberOfPendingClosedTabs(windowId);
  clearTimeoutForWindowId(windowId);
  var timeout = setTimeout(function(){
    onTabChanged(tabId, windowId);
  }, 5000);
  windowIdToTimeout[windowId] = {count: count, timeout: timeout};
}

// cancels the timer on a window
function clearTimeoutForWindowId(windowId) {
  var timeoutData = windowIdToTimeout[windowId];
  if (timeoutData) {
    clearTimeout(timeoutData.timeout);
    delete windowIdToTimeout[windowId];
  }
}

// returns the number of onTabClose events that are pending for this window
function getNumberOfPendingClosedTabs(windowId) {
  var timeoutData = windowIdToTimeout[windowId];
  if (timeoutData) {
    return timeoutData.count;
  } else {
    return 0;
  }
}

/* WINDOW EVENTS */

function onWindowRemoved(windowId) {
  var windowName = windowIdToName[windowId];
  if (windowName) {
    var savedWindow = savedWindows[windowName];
    markWindowAsClosed(savedWindow);
  }
  clearTimeoutForWindowId(windowId);
}
chrome.windows.onRemoved.addListener(onWindowRemoved);

</script>

<!--
During development, this file loads debugging code.
The packaging script replaces it with a file that does nothing.
-->
<script src="debug.js"></script>
