<script type="text/javascript">

/*

The background page is responsible for the following:
* keeping track of the saved state, as well as what's open.
* retrieving, storing and updating this state in localStorage.
* listening for window/tab events to keep our state up to date.
* saving, opening and deleting windows actions from the popups.

*/

var DEFAULT_NAME = "Window";

// an array of the names of all saved windows.
var savedWindowNames = restoreFromLocalStorage("savedWindowNames", new Array());

// saved windows, keyed by name.
var savedWindows = new Object();

// maps open windowIds to saved windows.
var windowIdToName = new Object();

// Unfortunately, removing a tab doesn't give us a windowId
// so we need to keep track of that mapping.
var tabIdToWindowId = new Object();

// TODO: add badge

// populate savedWindows from local storage
// as we go, try matching them to open windows.
chrome.windows.getAll({populate:true}, function(openWindows) {
	for (var i in savedWindowNames) {
		var name = savedWindowNames[i];
		// TODO: handle non-existent window object more gracefully
		w  = restoreFromLocalStorage(name);
		if (w) {
			savedWindows[name] = w;
			w.getDisplayName = getDisplayName;
			// by default, we assume the window is closed (id is undefined)
			delete w.id; 
			// now, let's check if it's one of the open windows
			for (var j in openWindows) {
				if (windowsAreEqual(w, openWindows[j])) {
					w.id = openWindows[j].id;				
					windowIdToName[w.id] = w.name;
					break;
				}
			}
		}
	}
});

// helper function to restore from localStorage
function restoreFromLocalStorage(key, defaultValue) {
	if (localStorage[key]) {
		return JSON.parse(localStorage[key]);
	} else {
		localStorage[key] = JSON.stringify(defaultValue);
		return defaultValue;
	}
}

// compares two window objects
function windowsAreEqual(window1, window2) {
	if (window1.incognito != window2.incognito) {
		return false;
	}
	if (!window1.tabs || !window2.tabs) {
		return false;
	}
	if (window1.tabs.length != window2.tabs.length) {
		return false;
	}
	for (var i in window1.tabs) {
		if (window1.tabs[i].url != window2.tabs[i].url) {
			return false;
		}
	}
	return true;
}

// save a window
// TODO: refactor to re-use updateWindow
function saveWindow(w, name) {
	name = (name == "") ? DEFAULT_NAME : name; 
	// handle duplicate names
	var n = 0;
	w.displayName = name;
	while(savedWindows[name]) {
		name = w.displayName + n;
		n++;
	}
	w.name = name;
	w.getDisplayName = getDisplayName;
	
	// update variables and save to local storage
	savedWindows[name] = w;
	localStorage[name] = JSON.stringify(w);
	savedWindowNames.push(name);
	localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
	windowIdToName[w.id] = w.name;
}

// update a saved window
function updateWindow(windowId) {
	if (windowIdToName[windowId]) {
		chrome.windows.get(windowId, function(newWindow) {
			chrome.tabs.getAllInWindow(windowId, function(tabs) {
				windowName = windowIdToName[windowId];
				w = savedWindows[windowName];
				
				// populate new window
				newWindow.name = windowName;
				newWindow.displayName = w.displayName;
				newWindow.getDisplayName = getDisplayName;
				newWindow.tabs = tabs;
				
				// save new window
				savedWindows[windowName] = newWindow;
				localStorage[windowName] = JSON.stringify(newWindow);
	
				// update tabIdToWindowId
				for (var i in newWindow.tabs) {
					tabIdToWindowId[newWindow.tabs[i].id] = newWindow.id;
				}
			});
		});
		return true;
	} else {
		return false;
	}
}

// restore a previously saved window
function openWindow(savedWindow) {
	// TODO: add window parameters
	chrome.windows.create({url:savedWindow.tabs[0].url}, function(w){
		windowIdToName[w.id] = savedWindow.name;
		savedWindow.id = w.id;
		for (var i in savedWindow.tabs) {
			if (i > 0) {
				// TODO: add tab parameters
				// TODO: file bug to allow window creation with multiple tabs
				chrome.tabs.create({url:savedWindow.tabs[i].url});
			}
		}
	});
	// TODO: add an else clause to select the window if it already exists
}

// removed a saved window
function deleteSavedWindow(name) {
	delete localStorage[name];
	
	savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
	localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
	
	w = savedWindows[name];
	delete windowIdToName[w.id];
	
	delete savedWindows[name];
	
	return w.displayName;
}

// adds the number of tabs in parentheses after a window's displayName
function getDisplayName() {
	return this.displayName + " (" + this.tabs.length + ")";
}

// wipe all the state
function CLEAR_ALL() {
	for (var i in savedWindowNames) {
		delete localStorage[savedWindowNames[i]];
	}
	delete localStorage["savedWindowNames"];
	savedWindowNames = restoreFromLocalStorage("savedWindowNames", new Array());
	savedWindows = new Object();
	windowIdToName = new Object();
	tabIdToWindowId = new Object();
}

/* TAB EVENTS */

function onTabAttached(tabId, info) {
	updateWindow(info.newWindowId);
	// TODO: what do we do if this was the last tab of a saved window?
}
chrome.tabs.onAttached.addListener(onTabAttached);

function onTabCreated(tab) {
	windowWasUpdated = updateWindow(tab.windowId);
	if (windowWasUpdated) {
		tabIdToWindowId[tab.id] = tab.windowId;
	}
}
chrome.tabs.onCreated.addListener(onTabCreated);

function onTabDetached(tabId, info) {
	windowWasSaved = updateWindow(info.oldWindowId);
	if (windowWasSaved) {
		delete tabIdToWindowId[tabId];
	}
}
chrome.tabs.onDetached.addListener(onTabDetached);

function onTabMoved(tabId, info) {
	updateWindow(info.windowId);
}
chrome.tabs.onMoved.addListener(onTabMoved);

function onTabRemoved(tabId) {
	// because closing the window triggers tab deletion events
	// we set a timeout so the window removal event has the time to trigger
	// and we don't accidentally delete a saved window
	// TODO: improve this algorithm
	setTimeout(function(){
		windowId = tabIdToWindowId[tabId];
		updateWindow(windowId);
		// TODO: can we handle the case when we close the last tab
	}, 5000);
}
chrome.tabs.onRemoved.addListener(onTabRemoved);

// TODO: implement selection
// chrome.tabs.onSelectionChanged.addListener(function(tabId, info) {});

function onTabUpdated(tabId, info, tab) {
	windowName = windowIdToName[tab.windowId];
	if (windowName) {
		w = savedWindows[windowName];
		w.tabs[tab.index] = tab;
		localStorage[w.name] = JSON.stringify(w);
	}
}
chrome.tabs.onUpdated.addListener(onTabUpdated);

/* WINDOW EVENTS */

// TODO: do we need this?
function onWindowCreated(w) {
	for (var i in savedWindows) {
		savedWindow = savedWindows[i];
		if (windowsAreEqual(savedWindow,w)) {
			savedWindow.id = w.id;
			windowIdToName[w.id] = savedWindow.name;
		}
	}
}
chrome.windows.onCreated.addListener(onWindowCreated);

function onWindowRemoved(windowId) {
	windowName = windowIdToName[windowId];
	if (windowName) {
		w = savedWindows[windowName];
		delete w.id;
		delete windowIdToName[windowId];
	}
}
chrome.windows.onRemoved.addListener(onWindowRemoved);

/* TODO: send feedback KATHY
	delete window triggers delete tabs
	create tabs comes back to you
*/

</script>