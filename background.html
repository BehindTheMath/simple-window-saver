<script src="eventHandlers.js"></script>
<script src="badge.js"></script>
<script>

/*

The background page is responsible for the following:
* keeping track of the saved state, as well as what's open.
* retrieving, storing and updating this state in localStorage.
* listening for window/tab events to keep our state up to date.
* saving, opening and deleting windows actions from the popups.

FEATURE: omnibox support

*/

var DEFAULT_NAME = "Window";

/* BASIC STATE */
// an array of the names of all saved windows
var savedWindowNames = restoreFromLocalStorage("savedWindowNames", new Array());

// saved windows, keyed by name
// If the savedWindow has an id, it is currently open.
// Each savedWindow can only correspond to one open window at any given time.
var savedWindows = new Object();

// map the ids of open windows to saved window names
// used to respond to events
var windowIdToName = new Object();

/* EDGE CASES */
// saved windows that aren't currently open, keyed by name
// used to match new windows to saved windows that are still closed
var closedWindows = new Object();

// Unfortunately, removing a tab doesn't give us a windowId
// so we need to keep track of that mapping.
var tabIdToSavedWindowId = new Object();

// used to count how many times we show the update message
var updateMsgCount = restoreFromLocalStorage("updateMsgCount", 0);

// object that stores per-window flags as to whether API indicated
// window-closing intention on tab removal
var isWindowClosing = new Object();

/* INIT */

// if the extension has been updated, show the update message 5 times
if (parseFloat(localStorage.version) < 1.1) {
  updateMsgCount = 5;
  localStorage.version = "1.1";
}
if (updateMsgCount > 0) {
  updateBadgeForAllWindows();
}

// populate savedWindows from local storage
// as we go, try matching them to open windows
chrome.windows.getAll({populate:true}, function(openWindows) {
  for (var i in savedWindowNames) {
    var name = savedWindowNames[i];
    var savedWindow  = restoreFromLocalStorage(name);
    if (savedWindow) {
      savedWindows[name] = savedWindow;
      // by default, we assume the window is closed (id is undefined)
      delete savedWindow.id;
      // now, let's check if it's one of the open windows
      for (var j in openWindows) {
        var w = openWindows[j];
        if (windowsAreEqual(w, savedWindow)) {
          storeWindow(w, name, savedWindow.displayName);
          markWindowAsOpen(w);
          break;
        }
      }
      if (!savedWindows[name].id) {
        closedWindows[name] = savedWindows[name];
      }
    } else {
      console.error("Window " + name + " was not found in localStorage.");
      savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
      localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
    }
  }
});

// helper function to restore from localStorage
function restoreFromLocalStorage(key, defaultValue) {
  if (localStorage[key]) {
    return JSON.parse(localStorage[key]);
  } else {
    localStorage[key] = JSON.stringify(defaultValue);
    return defaultValue;
  }
}

// compares a current window to a saved window
// we are optimistic here: as long as the tabs of the new window
// match those of the saved window, we consider them equal
// even if the new window has more tabs
// TODO: try disregarding query strings (might be better?)
function windowsAreEqual(currentWindow, savedWindow) {
  if (currentWindow.incognito) {
    return false;
  }
  if (!currentWindow.tabs || !savedWindow.tabs) {
    return false;
  }
  if (currentWindow.tabs.length < savedWindow.tabs.length) {
    return false;
  }
  for (var i in savedWindow.tabs) {
    if (currentWindow.tabs[i].url != savedWindow.tabs[i].url) {
      return false;
    }
  }
  return true;
}

// save a window
// returns the saved window object
function saveWindow(w, displayName) {
  var displayName = (displayName == "") ? DEFAULT_NAME : displayName;
  // handle duplicate names
  var name = displayName;
  var n = 0;
  while(savedWindows[name]) {
    name = displayName + n;
    n++;
  }

  // add window to indexes
  savedWindowNames.push(name);
  localStorage.savedWindowNames = JSON.stringify(savedWindowNames);

  storeWindow(w, name, displayName);

  if (w.id) {
    markWindowAsOpen(w);
  }

  return w;
}

// store a window object
// returns the stored window
function storeWindow(w, name, displayName) {
  w.name = name;
  w.displayName = displayName;

  savedWindows[name] = w;
  localStorage[name] = JSON.stringify(w);

  return w;
}

function markWindowAsOpen(w) {
  delete closedWindows[w.name];
  windowIdToName[w.id] = w.name;
  for (var i in w.tabs) {
    tabIdToSavedWindowId[w.tabs[i].id] = w.id;
  }
  updateBadgeForWindow(w.id);
}

function markWindowAsClosed(w) {
  delete windowIdToName[w.id];
  closedWindows[w.name] = w;
  delete w.id;
}

// restore a previously saved window
function openWindow(name) {
  chrome.tabs.getSelected(null, function(tab){
    // if the window was opened from a new tab, close the new tab
    if (tab.url == "chrome://newtab/") {
      chrome.tabs.remove(tab.id);
    }

    // compile the raw list of urls
    var savedWindow = savedWindows[name];
    var urls = [];
    for (i in savedWindow.tabs) {
      urls[i] = savedWindow.tabs[i].url;
    }

    // create a window and open the tabs in it.
    var createData = {url: urls};
    var callback = function (w) { onWindowOpened(savedWindow, w); };
    chrome.windows.create(createData, callback);
  });
}


// this is a little helper function
// we need it because if we don't have a window yet
// we'll need to do this work asynchronously
function onWindowOpened(savedWindow, w) {
  savedWindow.id = w.id;
  markWindowAsOpen(savedWindow);

  // pinned tabs
  for (var i in savedWindow.tabs) {
    if (savedWindow.tabs[i].pinned) {
      chrome.tabs.update(w.tabs[i].id, {pinned: true});
    }
  }
}

// removed a saved window
function deleteSavedWindow(name) {
  var savedWindow = savedWindows[name];

  var id = savedWindow.id;
  if (id) {
    markWindowAsClosed(savedWindow);
    updateBadgeForWindow(id);
    for (var i in savedWindow.tabs) {
      delete tabIdToSavedWindowId[savedWindow.tabs[i].id];
    }
  }

  delete closedWindows[savedWindow.name];
  delete localStorage[name];
  delete savedWindows[name];
  savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
  localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
}



</script>

<!--
During development, this file loads debugging code.
The packaging script replaces it with a file that does nothing.
-->
<script src="debug.js"></script>
