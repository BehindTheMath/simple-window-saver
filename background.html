<script type="text/javascript">

/*

The background page is responsible for the following:
* keeping track of the saved state, as well as what's open.
* retrieving, storing and updating this state in localStorage.
* listening for window/tab events to keep our state up to date.
* saving, opening and deleting windows actions from the popups.

P1: massive refactor to store data in bookmarks
	Pros: adding/merging/reorganizing, sync
	Cons: complexity, hard to store extra info, folders
P1: add a proper icon
P1: figure out what happens if there are two saved windows with the same content
TODO: create release script (remove debug, compile javascript/CSS, etc)
TODO: split background.HTML into multiple JS files (closure?)

*/

var DEFAULT_NAME = "Window";

// an array of the names of all saved windows.
var savedWindowNames = restoreFromLocalStorage("savedWindowNames", new Array());

// saved windows, keyed by name.
var savedWindows = new Object();

// maps open windowIds to saved windows.
var windowIdToName = new Object();

// Unfortunately, removing a tab doesn't give us a windowId
// so we need to keep track of that mapping.
var tabIdToWindowId = new Object();

// populate savedWindows from local storage
// as we go, try matching them to open windows.
chrome.windows.getAll({populate:true}, function(openWindows) {
	for (var i in savedWindowNames) {
		var name = savedWindowNames[i];
		// P1: handle non-existent window object more gracefully
		var w  = restoreFromLocalStorage(name);
		if (w) {
			savedWindows[name] = w;
			w.getDisplayName = getDisplayName;
			// by default, we assume the window is closed (id is undefined)
			delete w.id; 
			// now, let's check if it's one of the open windows
			for (var j in openWindows) {
				if (windowsAreEqual(openWindows[j], w)) {
					w.id = openWindows[j].id;				
					windowIdToName[w.id] = w.name;
					break;
				}
			}
		}
	}
	for (var j in openWindows) {
		updateBadgeForWindow(openWindows[j].id);
	}
});

// helper function to restore from localStorage
function restoreFromLocalStorage(key, defaultValue) {
	if (localStorage[key]) {
		return JSON.parse(localStorage[key]);
	} else {
		localStorage[key] = JSON.stringify(defaultValue);
		return defaultValue;
	}
}

// compares a current window to a saved window
// we are optimistic here: as long as the tabs of the new window
// match those of the saved window, we consider them equal
// even if the new window has more tabs
function windowsAreEqual(currentWindow, savedWindow) {
	if (currentWindow.incognito != savedWindow.incognito) {
		return false;
	}
	if (!currentWindow.tabs || !savedWindow.tabs) {
		return false;
	}
	if (currentWindow.tabs.length < savedWindow.tabs.length) {
		return false;
	}
	for (var i in savedWindow.tabs) {
		if (currentWindow.tabs[i].url != savedWindow.tabs[i].url) {
			return false;
		}
	}
	return true;
}

// save a window
// returns the saved window object
function saveWindow(w, displayName) {
	displayName = (displayName == "") ? DEFAULT_NAME : displayName; 
	// handle duplicate names
	var name = displayName;
	var n = 0;
	while(savedWindows[name]) {
		name = displayName + n;
		n++;
	}
	
	// add window to indexes
	savedWindowNames.push(name);
	localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
	windowIdToName[w.id] = name;
	
	updateBadgeForWindow(w.id);
	
	return storeWindow(w, name, displayName);
}

// update a saved window
// returns true if the window existed, false otherwise
function updateWindow(windowId) {
	if (windowIdToName[windowId]) {
		chrome.windows.get(windowId, function(w) {
			chrome.tabs.getAllInWindow(windowId, function(tabs) {
				w.tabs = tabs;
				var name = windowIdToName[windowId];
				var displayName = savedWindows[name].displayName;
				storeWindow(w, name, displayName);
			});
		});
		return true;
	} else {
		return false;
	}
}

// store a window object
// returns the stored window
function storeWindow(w, name, displayName) {
	w.name = name;
	w.displayName = displayName;
	w.getDisplayName = getDisplayName;
	
	savedWindows[name] = w;
	localStorage[name] = JSON.stringify(w);
	
	// update tabIdToWindowId
	for (var i in w.tabs) {
		tabIdToWindowId[w.tabs[i].id] = w.id;
	}
	
	return w;
}

// restore a previously saved window
function openWindow(savedWindow) {
	chrome.tabs.getSelected(null, function(tab){
		console.log(tab);
		if(tab.url == "chrome://newtab/") {
			chrome.tabs.remove(tab.id);
		}
	});
	chrome.windows.create({url:savedWindow.tabs[0].url}, function(w){
		windowIdToName[w.id] = savedWindow.name;
		savedWindow.id = w.id;
		for (var i in savedWindow.tabs) {
			if (i > 0) {
				// TODO: there could be a race here, if the window gets saved
				chrome.tabs.create({url:savedWindow.tabs[i].url});
			}
		}
	});
}

// removed a saved window
// returns the displayName of the removed window
function deleteSavedWindow(name) {
	w = savedWindows[name];
	
	delete localStorage[name];
	delete savedWindows[name];
	delete windowIdToName[w.id];
	savedWindowNames.splice(savedWindowNames.indexOf(name), 1);
	localStorage.savedWindowNames = JSON.stringify(savedWindowNames);
	
	updateBadgeForWindow(w.id);
	
	return w.displayName;
}

// adds the number of tabs in parentheses after a window's displayName
// TODO: make this aware of pending deletions and creations
function getDisplayName() {
	return this.displayName + " (" + this.tabs.length + ")";
}

/* BADGE FUNCTIONS */
// Because chrome doesn't support per-window badges, we maintain it per-tab
// and update it on both window and tab selection changes

// updates the browserAction badge to show the window as saved
function showSavedBadge(tabId) {
	chrome.browserAction.setBadgeText({text:"v", tabId:tabId});
	chrome.browserAction.setBadgeBackgroundColor(
		{color:[0,255,0,255], tabId:tabId});
}

// updates the browserAction badge to show the window as unsaved
// because chrome doesn't support per-window badges, we do it per-tab
// and update it on both window and tab selection changes
function showUnsavedBadge(tabId) {
	chrome.browserAction.setBadgeText({text:"", tabId:tabId});
}

// update the badge for the given tab
function updateBadgeForTab(tab) {
	if(windowIdToName[tab.windowId]) {
		showSavedBadge(tab.id);
	} else {
		showUnsavedBadge(tab.id);
	}
}

// update the badge for the given window
function updateBadgeForWindow(windowId) {
	if(windowId != -1) {
		chrome.tabs.getSelected(windowId, updateBadgeForTab);
	}
}

/* TAB EVENTS */
// For most tab events, we simply resave the entire window.
// While a bit more wasteful, this makes the code much more robust.

function onTabAttached(tabId, info) {
	updateWindow(info.newWindowId);
	// P1: what do we do if this was the last tab of a saved window?
}
chrome.tabs.onAttached.addListener(onTabAttached);

function onTabCreated(tab) {
	windowWasUpdated = updateWindow(tab.windowId);
	if (windowWasUpdated) {
		tabIdToWindowId[tab.id] = tab.windowId;
	}
}
chrome.tabs.onCreated.addListener(onTabCreated);

function onTabDetached(tabId, info) {
	windowWasSaved = updateWindow(info.oldWindowId);
	if (windowWasSaved) {
		delete tabIdToWindowId[tabId];
	}
}
chrome.tabs.onDetached.addListener(onTabDetached);

function onTabMoved(tabId, info) {
	updateWindow(info.windowId);
}
chrome.tabs.onMoved.addListener(onTabMoved);

function onTabRemoved(tabId) {
	// because closing the window triggers tab deletion events
	// we set a timeout so the window removal event has the time to trigger
	// and we don't accidentally delete a saved window
	// TODO: improve this algorithm
	setTimeout(function(){
		windowId = tabIdToWindowId[tabId];
		updateWindow(windowId);
		// P1: can we handle the case when we close the last tab
	}, 5000);
}
chrome.tabs.onRemoved.addListener(onTabRemoved);

function onTabSelectionChanged(tabId, info) {
	updateWindow(info.windowId);
	updateBadgeForTab({id: tabId, windowId: info.windowId});
}
chrome.tabs.onSelectionChanged.addListener(onTabSelectionChanged);

function onTabUpdated(tabId, info, tab) {
	windowName = windowIdToName[tab.windowId];
	if (windowName) {
		w = savedWindows[windowName];
		w.tabs[tab.index] = tab;
		localStorage[w.name] = JSON.stringify(w);
	}
	updateBadgeForTab(tab);
}
chrome.tabs.onUpdated.addListener(onTabUpdated);

/* WINDOW EVENTS */

// TODO: do we need this?
function onWindowCreated(w) {
	for (var i in savedWindows) {
		savedWindow = savedWindows[i];
		if (windowsAreEqual(w, savedWindow)) {
			savedWindow.id = w.id;
			windowIdToName[w.id] = savedWindow.name;
		}
	}
}
chrome.windows.onCreated.addListener(onWindowCreated);

function onWindowRemoved(windowId) {
	windowName = windowIdToName[windowId];
	if (windowName) {
		w = savedWindows[windowName];
		delete w.id;
		delete windowIdToName[windowId];
	}
}
chrome.windows.onRemoved.addListener(onWindowRemoved);

chrome.windows.onFocusChanged.addListener(updateBadgeForWindow);

/* TODO: send feedback

	KATHY
	delete window triggers delete tabs
	create tabs comes back to you
	document that badges are per tab AND PER URL
	
	EXTENSIONS TEAM
	onTabRemoved should include the oldWindowId
	chrome.windows.get should include the populate parameter
	chrome.windows.create should support a tab array
	right click in popup should allow to inspect
	css should not be cached while in developer mode
	support debug mode (example: CSS buster)
	support for changing the focused window
	support unicode or html characters in browserAction badges
*/

</script>